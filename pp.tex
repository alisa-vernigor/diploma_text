\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{inconsolata}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Designing a Type-Safe Remote Procedure Call Protocol\\
%{\footnotesize \textsuperscript{*}Note: Sub-titles are not captured in Xplore and
%should not be used}
}

\author{\IEEEauthorblockN{Alisa Vernigor}
\IEEEauthorblockA{\textit{Faculty of Computer Science} \\
\textit{Higher School of Economics}\\
Moscow, Russia \\
aivernigor@edu.hse.ru}
}

\maketitle

\begin{abstract}
The goal of this project is to develop a new data serialization format called DependoBuf (DBuf). It supports dependent types and can be used in place of Protocol Buffers (protobuf). We will leverage the latest developments in programming languages and formal methods for type systems to design the DBuf format and use Lex and Yacc to implement a compiler that generates source code to serialize and deserialize DBuf messages in different programming languages. We will evaluate the performance and efficiency of the DBuf format and explore potential integration with gRPC. The aim is to provide developers with a new tool to improve the performance and reliability of their applications. While DBuf is not a drop-in replacement for protobuf, we will ensure that it is as easy as possible for users to transition to DBuf by ensuring that the format is compatible with existing programming languages and type systems.
\end{abstract}

\begin{IEEEkeywords}
  code generation, data formats, dependent types, schema language
\end{IEEEkeywords}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ 
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
  basicstyle=\fontsize{11}{10}\selectfont\ttfamily,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  %breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
%  commentstyle=\color{mygreen},    % comment style
%  deletekeywords={...},            % if you want to delete keywords from the given language
%  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
%  firstnumber=1000,                % start line enumeration with line 1000
  %frame=tb,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
%  keywordstyle=\color{blue},       % keyword style
  language=Octave,                 % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  %numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\fontsize{7.5}{10}\selectfont\ttfamily\color{mygray}, % the style that is used for the line-numbers
%  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
 % stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\section{Introduction}
Data serialization is an essential component of the modern technology landscape, enabling the efficient and accurate transfer of data between different systems and applications. The ability to serialize data, or convert it into a compact and easily transferable format, has become increasingly important as the amount of data generated by systems and devices continues to grow at an unprecedented rate.

However, existing serialization formats such as JSON, XML, and Protobuf are not sufficient to support all use cases. In particular, the lack of dependent types in these formats severely limits the expressiveness of the serialized data. Dependent types, which express constraints on the type of data, are critical for ensuring data consistency and correctness, especially in safety-critical systems and applications.

Research into dependent types has yielded promising results, but so far the only serialization format that supports dependent types is Telegram's Type Language (TL). Unfortunately, TL's syntax is very different from commonly used formats such as Protobuf, and it lacks open source compilers, making it difficult for many developers to adopt.

TL's syntax and limited tools have made it a less-than-ideal choice for developers wishing to use dependent types in their serialization formats. While TL has demonstrated the potential of dependent types, it has not yet achieved widespread adoption due to these issues.

To address these challenges, we propose DependoBuf (DBuf), a new data serialization format that draws inspiration from Protobuf and the dependent type system in Agda. DBuf supports dependent types and has a syntax that is easy to understand and use for developers already familiar with Protobuf. We believe that DBuf will fill a critical gap in the market by providing a serialization format that is both powerful and accessible to a wide range of developers.

\section{Literature Review}
The need for efficient and standardized methods of transferring data between systems has increased with the advancements in computing technology. Various data formats, including XML \cite{xml} and JSON \cite{json}, have been created to facilitate data transfer, with text-based formats such as these being some of the first to emerge. While text formats are human-readable, they require a lot of storage space and generate additional network load when sent. While text formats remain popular for tasks where readability is important, binary formats have become increasingly popular, especially for large-scale distributed systems, where performance is critical.

Protocol Buffers (Protobufs) \cite{protobuf} is one of the most popular binary formats today due to its efficiency, interoperability, maintainability, and safety. Protobufs are designed to be language- and platform-neutral, forward- and backward-compatible, and less error-prone than text-based formats because they are strongly typed. The Protoc command-line tool is used to compile Protocol Buffers schema files into source code for various programming languages, freeing developers from the responsibility of serializing and deserializing the data. The adoption of Protobufs has been further accelerated by the widespread adoption of gRPC \cite{grpc}, a high-performance, open-source RPC framework that uses Protobufs for efficient data transfer.

As software systems become more complex, type safety becomes increasingly important. Type safety is the concept that a programming language should prevent operations or expressions from being applied to values of the wrong type. Dependent types take the idea of type safety further by allowing types to depend on values or other types, providing additional safety guarantees such as maintaining invariants or preventing certain types of errors from occurring. Research into dependent types has been going on for a long time, both in theory \cite{types} and in programming languages \cite{pr}. However, in the area of data formats, the topic is still rather unexplored. Current mainstream serialization formats such as JSON, XML, and Protocol Buffers do not support dependent types. Support for dependent types can provide stronger guarantees of correctness and security, particularly in distributed systems handling sensitive or critical data.

However, there has been relatively little research in this area, with the only known work on dependent types in data transfer formats being the Telegram Type Language (TL) \cite{tl}. Despite its potential, TL has several limitations. For example, its syntax differs significantly from that of the most common data formats, making it difficult for developers to adopt, and the lack of an open source compiler and comprehensive documentation further limits its usability. There is therefore a clear need for a new open source data transfer format that supports dependent types and is easy for developers to adopt.

\section{Methodology}
\subsection{Syntax}
DependoBuf (DBuf) is a proposed new language that aims to address the issues with the current serialization formats described above. To make it easier for programmers to learn the language, it is based on the syntax of the popular Protobuf data format.

    The syntax of a Protobuf file consists of messages, which are structures with fields. Similarly, the basis of DependoBuf is also structured around messages. This ensures that programmers who are already familiar with Protobuf can quickly adapt to the new language.

    Dependent types are an important feature of the language, allowing more expressive and accurate type checking. The construction of dependent types is achieved using constructors and pattern matching. Both are included in the language.

    The type Nat on Fig. \ref{fig1} is used as an example to demonstrate how DependoBuf uses constructors. The Nat type has two constructors, Zero and Succ, the latter of which has a field, prev. The curly braces after the constructor list the fields of the structure if created by that constructor.

    \begin{lstlisting}[caption={Type Nat in DependoBuf.},label={fig1}]
    message Nat {
        enum {
            Zero,
            Succ {
                prev Nat    
            }
        }
    }
    \end{lstlisting}

    
    In DependoBuf, dependencies between messages are expressed by listing them in parentheses after the message name. For example, RandomMessage (dep1 DepOne) (dep2 DepTwo) ... (depn DepN).


    Pattern matching is performed using the constructors of the message dependencies. If there are multiple dependencies, the constructors are listed in the order described after the dependent message name, separated by commas. The fields of a message created by the dependency constructor can be captured within curly braces following the constructor's name. In this case, these fields are also used in pattern matching. For each case described, the corresponding dependent message constructors with fields are listed in the enum. If a case does not match any of the above, it is matched by the special character *. It is important to note that cases are evaluated in the order in which they are declared.

    In the pattern matching example provided in Fig. \ref{fig2}, the RandomMessage type depends on a single Nat value called n. The pattern matching rules specify how the program should handle different cases of the n value. For example, if n is Zero, the program should use the Constructor1, while if n is a Succ constructor with a field prev, the program should use the Constructor2 with a single field number of type Nat equal to prev.

    \begin{lstlisting}[caption={RandomMessage depend on Nat message, pattern-matching example.},label={fig2}]
    message RandomMessage (n Nat) {
        Zero => enum {
            Constructor1 {
                ...    
            }
        },
        Succ {number : prev} => enum {
            Constructor22 {
                number Nat
            }
        }
    }
    \end{lstlisting}

    For a more complete understanding of the DependoBuf syntax, a strict EBNF description of the language is included in the Appendix \ref{FirstAppendix}.

\subsection{Stages of Work and Tools}
The first step in creating a schema language is to define its syntax, which involves specifying the rules for how the language's code is written. To implement these rules, we will use a scanner and a parser.

The scanner, also known as a lexer, breaks down the source code into individual tokens. These tokens represent the basic building blocks of the language, such as keywords, identifiers, operators, and literals. We will use the Lex tool to create the scanner, as it allows us to define patterns that match specific tokens in the input text.

Once the scanner has identified the tokens in the input code, the parser takes these tokens and generates a tree-like structure called an Abstract Syntax Tree (AST). This tree represents the structure of the code and its relationships. It serves as the basis for subsequent processing steps. We will use the tool Yacc to create the parser, as it provides a convenient way of specifying the grammar of the language using a BNF-like notation.

To ensure that the syntax of the language is correct, the parser will perform a syntax check by comparing the input code with the rules specified in the grammar. If the input code violates any of these rules, the parser will generate an error message indicating the location and nature of the error.

Once we have a working scanner and parser we can start adding more features to the language, such as type checking, code optimization and code generation. These features will allow us to create a robust and useful schema language, building on the foundation laid by the scanner and parser. In the code generation phase, we will generate code in two popular programming languages: Go and TypeScript. Go is a popular choice for back-end systems due to its efficient performance and seamless integration with protobufs and gRPC, while TypeScript is a widely-used language for front-end development that provides strong typing and supports modern web development practices.

\section{Results}
The main expected results of this project are the successful implementation of the parser and scanner stages of the DependoBuf language using Lex and Yacc, and the generation of code in the Go and Typescript programming languages. We aim to demonstrate that the DependoBuf language is capable of generating valid code in multiple languages and that it is a valuable tool for developers who require type safety and dependent types in their projects.

\section{Conclusion}

We have developed DependoBuf, a data serialization format that supports dependent types. The format offers a secure transport mechanism that reduces the number of errors that occur during data transfer. The security comes from the nature of our language, which ensures type safety and prevents data corruption.

However, DependoBuf has some limitations, including a lack of support for gRPC technology and limited compatibility with programming languages. We plan to address these issues in the future.

Our primary objective is to provide developers with a reliable and secure data format that supports dependent types. We plan to achieve this by defining the language syntax, creating a language scanner, parser, and type checker, and developing code generation for Go and Typescript languages. Testing our language on real systems will help us evaluate its effectiveness.

In summary, we believe that DependoBuf will be an important tool for developers who value type safety and security. As we continue to work on the language, we will strive to address its limitations and extend its compatibility with programming languages.

\bibliographystyle{IEEEtran}
\bibliography{pp}

\vspace{12pt}

\rightline{Word Count: 1685}

\lstset{ 
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
  basicstyle=\fontsize{7.5}{10}\selectfont\ttfamily,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  %breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
%  commentstyle=\color{mygreen},    % comment style
%  deletekeywords={...},            % if you want to delete keywords from the given language
%  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
%  firstnumber=1000,                % start line enumeration with line 1000
  %frame=tb,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
%  keywordstyle=\color{blue},       % keyword style
  language=Octave,                 % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\fontsize{7.5}{10}\selectfont\ttfamily\color{mygray}, % the style that is used for the line-numbers
%  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
 % stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\newpage
\appendices
\onecolumn
\section{EBNF description of the language}
\label{FirstAppendix}
\begin{lstlisting}
schema = {message_definition | service_definition};

message_definition = dependent_message | independent_message;
dependent_message = "message" type_identifier {type_dependency} dependent_message_body nl;
type_dependency = "(" variable_identifier type_spec ")";
dependent_message_body = "{" nl {pattern_matching {"," pattern_matching} "=>" {constructors_block | fields_block}} "}" nl;
pattern_matching = "*" | value | (constructor_identifier ["{" {field_identifier {":" variable_identifier}} "}"] );

independent_message = "message" type_identifier independent_message_body nl;
independent_message_body = fields_block | ("{" {constructors_block | fields_block} "}" nl);

constructors_block = "enum" "{" nl {constructor_identifier {fields_block | nl}} "}" nl;
fields_block = "{" nl {field_declaration} "}" nl;
field_declaration = field_identifier ws type_spec nl;

service_definition = "service" service_identifier "{" nl {rpc_definition} "}" nl;
rpc_definition = "rpc" rpc_identifier "("  [arguments]  ")" "returns" "(" type_spec ")" nl;
arguments = argument {"," argument};
argument = variable_identifier ws type_spec;

uppercase_identifier = uppercase_letter {letter | digit};
lowercase_identifier = lowercase_letter {letter | digit};

type_identifier = uppercase_identifier;
constructor_identifier = uppercase_identifier;
field_identifier = lowercase_identifier;
service_identifier = uppercase_identifier;
rpc_identifier = uppercase_identifier;
variable_identifier = lowercase_identifier;

type_spec = primitive_type | (type_identifier {ws expression});
primitive_type = "Int8" | "Int16" | "Int32" | "Int64"
               | "Float16" | "Float32" | "Float64"
               | "String" | "Bool";

uppercase_letter = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
                 | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
                 | "U" | "V" | "W" | "X" | "Y" | "Z";
lowercase_letter = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j"
                 | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t"
                 | "u" | "v" | "w" | "x" | "y" | "z";
letter = uppercase_letter | lowercase_letter;
digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";

expression = value
           | variable_identifier
           | variable_identifier "." field_identifier
           | expression binary_op expression
           | prefix_op expression
           | "(" expression ")"
           ;

value = literal_value | constructed_value;

literal_value = bool_literal
        | float_literal
        | int_literal
        | string_literal
        ;

bool_literal = "true" | "false" ;
float_literal = {digit} "." digit {digit} [ ("e"|"E") [ "+" | "-" ] digit {digit} ] ;
int_literal = digit {digit} ;
string_literal = "\"" { character } "\"";

character = letter | digit | symbol | ws;
symbol = "~" | "!" | "@" | "#" | "$" | "%" | "^" 
       | "&" | "*" | "(" | ")" | "-" | "_" | "+" 
       | "=" | "{" | "}" | "[" | "]" | "|" | ";" 
       | ":" | "'" | "," | "." | "<" | ">" | "/" | "?" 
       ;

ws = (" " | "\t") {ws};
nl = "\n" | "\r\n";

constructed_value = constructor_identifier "{" {field_identifier ":" expression} "}";

binary_op = "+" | "-" | "*" | "/" | "<" | "<=" | ">" | ">=" | "=" | "!=" | "&&" | "||" ;
prefix_op = "-" | "!";
\end{lstlisting}

\end{document}
